1.put --   key的hashcode（还有其他的东西，各种位移） 得到hashcode的值 --4254525--作为数组下标越界，对这个大的数字进行取余
 数字%table的长度 --》index  （所以下标是随机的） k-v被封装成enty对象

如果hash冲突就采用链表的形式进行插入  （头插法（快，减少了遍历），然后下移一位，就能解决get方法，查找的问题）

（数组，enty、链表都是存在堆中的）数组中存的是enty对象的引用地址 链表也是 （移动的时候的改引用就可以了）

put的相同的key，会先进行遍历，找到key，（没有就使用头插法 ）会覆盖原始的value，并将原始的value覆盖掉

数组的默认为16，负载因子0.75
初始化的容量
根据指定的长度，如果为10，他会判断是否超过最大长度，是否比一小，比一小返回1，
不比一小，通过一个方法区找到大于等于2的幂次方的数
key等于的null，会存在hashmap的第0个位置





















